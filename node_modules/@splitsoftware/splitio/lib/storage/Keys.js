"use strict";

exports.__esModule = true;
exports.default = void 0;

var _lang = require("../utils/lang");

var everythingAtTheEnd = /[^.]+$/;
var everythingAfterCount = /count\.([^/]+)$/;
var latencyMetricNameAndBucket = /latency\.([^/]+)\.bucket\.([0-9]+)$/;

var KeyBuilder = /*#__PURE__*/function () {
  function KeyBuilder(settings) {
    this.settings = settings;
  }

  var _proto = KeyBuilder.prototype;

  _proto.buildSplitKey = function buildSplitKey(splitName) {
    return this.settings.storage.prefix + ".split." + splitName;
  };

  _proto.buildTrafficTypeKey = function buildTrafficTypeKey(trafficType) {
    return this.settings.storage.prefix + ".trafficType." + trafficType;
  };

  _proto.buildSplitsTillKey = function buildSplitsTillKey() {
    return this.settings.storage.prefix + ".splits.till";
  };

  _proto.buildSplitsReady = function buildSplitsReady() {
    return this.settings.storage.prefix + ".splits.ready";
  };

  _proto.isSplitKey = function isSplitKey(key) {
    return (0, _lang.startsWith)(key, this.settings.storage.prefix + ".split.");
  };

  _proto.buildSegmentNameKey = function buildSegmentNameKey(segmentName) {
    return this.settings.storage.prefix + ".segment." + segmentName;
  };

  _proto.buildSegmentTillKey = function buildSegmentTillKey(segmentName) {
    return this.settings.storage.prefix + ".segment." + segmentName + ".till";
  };

  _proto.buildRegisteredSegmentsKey = function buildRegisteredSegmentsKey() {
    return this.settings.storage.prefix + ".segments.registered";
  };

  _proto.buildSegmentsReady = function buildSegmentsReady() {
    return this.settings.storage.prefix + ".segments.ready";
  };

  _proto.buildVersionablePrefix = function buildVersionablePrefix() {
    return this.settings.storage.prefix + "/" + this.settings.version + "/" + this.settings.runtime.ip;
  };

  _proto.buildImpressionsKey = function buildImpressionsKey() {
    return this.settings.storage.prefix + ".impressions";
  };

  _proto.buildEventsKey = function buildEventsKey() {
    return this.settings.storage.prefix + ".events";
  };

  _proto.buildLatencyKeyPrefix = function buildLatencyKeyPrefix() {
    return this.buildVersionablePrefix() + "/latency";
  };

  _proto.buildLatencyKey = function buildLatencyKey(metricName, bucketNumber) {
    return this.buildLatencyKeyPrefix() + "." + metricName + ".bucket." + bucketNumber;
  };

  _proto.buildCountKey = function buildCountKey(metricName) {
    return this.buildVersionablePrefix() + "/count." + metricName;
  };

  _proto.buildGaugeKey = function buildGaugeKey(metricName) {
    return this.buildVersionablePrefix() + "/gauge." + metricName;
  };

  _proto.searchPatternForCountKeys = function searchPatternForCountKeys() {
    return this.buildVersionablePrefix() + "/count.*";
  };

  _proto.searchPatternForSplitKeys = function searchPatternForSplitKeys() {
    return this.settings.storage.prefix + ".split.*";
  };

  _proto.searchPatternForLatency = function searchPatternForLatency() {
    return this.buildLatencyKeyPrefix() + ".*";
  };

  _proto.extractKey = function extractKey(builtKey) {
    var s = builtKey.match(everythingAtTheEnd);

    if (s && s.length) {
      return s[0];
    } else {
      throw new Error('Invalid latency key provided');
    }
  };

  _proto.extractCounterName = function extractCounterName(counterKey) {
    var m = counterKey.match(everythingAfterCount);

    if (m && m.length) {
      return m[1]; // everything after count
    } else {
      throw new Error('Invalid counter key provided');
    }
  };

  _proto.extractLatencyMetricNameAndBucket = function extractLatencyMetricNameAndBucket(latencyKey) {
    var parts = latencyKey.match(latencyMetricNameAndBucket);

    if (parts && parts.length > 2) {
      return {
        metricName: parts[1],
        bucketNumber: parts[2]
      };
    } else {
      throw new Error('Invalid counter key provided');
    }
  };

  return KeyBuilder;
}();

var _default = KeyBuilder;
exports.default = _default;