"use strict";

exports.__esModule = true;
exports.parseKeyList = parseKeyList;
exports.parseBitmap = parseBitmap;
exports.isInBitmap = isInBitmap;

var _decompress = require("../../utils/decompress");

var _base = require("../../utils/base64");

var GZIP = 1;
var ZLIB = 2;

function Uint8ArrayToString(myUint8Arr) {
  return String.fromCharCode.apply(null, myUint8Arr);
}

function StringToUint8Array(myString) {
  var charCodes = myString.split('').map(function (e) {
    return e.charCodeAt();
  });
  return new Uint8Array(charCodes);
}
/**
 * Decode and decompress 'data' with 'compression' algorithm
 *
 * @param {string} data
 * @param {number} compression 1 GZIP, 2 ZLIB
 * @returns {Uint8Array}
 * @throws if data string cannot be decoded, decompressed or the provided compression value is invalid (not 1 or 2)
 */


function decompress(data, compression) {
  var compressData = (0, _base.decodeFromBase64)(data);
  var binData = StringToUint8Array(compressData);
  if (typeof _decompress.algorithms === 'string') throw new Error(_decompress.algorithms);
  if (compression === GZIP) return _decompress.algorithms.gunzipSync(binData);
  if (compression === ZLIB) return _decompress.algorithms.unzlibSync(binData);
  throw new Error("Invalid compression algorithm #" + compression);
}
/**
 * Decode, decompress and parse the provided 'data' into a KeyList object
 *
 * @param {string} data
 * @param {number} compression
 * @returns {{a?: string[], r?: string[] }}
 * @throws if data string cannot be decoded, decompressed or parsed
 */


function parseKeyList(data, compression) {
  var binKeyList = decompress(data, compression);
  var strKeyList = Uint8ArrayToString(binKeyList); // replace numbers to strings, to avoid losing precision

  return JSON.parse(strKeyList.replace(/\d+/g, '"$&"'));
}
/**
 * Decode, decompress and parse the provided 'data' into a Bitmap object
 *
 * @param {string} data
 * @param {number} compression
 * @returns {Uint8Array}
 * @throws if data string cannot be decoded or decompressed
 */


function parseBitmap(data, compression) {
  return decompress(data, compression);
}
/**
 * Check if the 'bitmap' bit at 'hash64hex' position is 1
 *
 * @param {Uint8Array} bitmap
 * @param {string} hash64hex 16-chars string, representing a number in hexa
 * @returns {boolean}
 */


function isInBitmap(bitmap, hash64hex) {
  // using the lowest 32 bits as index, to avoid losing precision when converting to number
  var index = parseInt(hash64hex.slice(8), 16) % (bitmap.length * 8);
  var internal = Math.floor(index / 8);
  var offset = index % 8;
  return (bitmap[internal] & 1 << offset) > 0;
}