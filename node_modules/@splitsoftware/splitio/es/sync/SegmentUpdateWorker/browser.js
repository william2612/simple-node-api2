import Backoff from '../../utils/backoff';
/**
 * MySegmentUpdateWorker class
 */

var MySegmentUpdateWorker = /*#__PURE__*/function () {
  /**
   *
   * @param {Object} mySegmentsStorage
   * @param {Object} mySegmentsProducer
   */
  function MySegmentUpdateWorker(mySegmentsStorage, mySegmentsProducer) {
    this.mySegmentsStorage = mySegmentsStorage;
    this.mySegmentsProducer = mySegmentsProducer;
    this.maxChangeNumber = 0; // keeps the maximum changeNumber among queued events

    this.segmentsData = undefined; // keeps the segmentsData (if included in notification payload) from the queued event with maximum changeNumber

    this.currentChangeNumber = -1; // @TODO: remove once `/mySegments` endpoint provides the changeNumber

    this.put = this.put.bind(this);
    this.__handleMySegmentUpdateCall = this.__handleMySegmentUpdateCall.bind(this);
    this.backoff = new Backoff(this.__handleMySegmentUpdateCall);
  } // Private method
  // Preconditions: this.mySegmentsProducer.isSynchronizingMySegments === false
  // @TODO update this block similar to SplitUpdateWorker, once `/mySegments` endpoint provides the changeNumber


  var _proto = MySegmentUpdateWorker.prototype;

  _proto.__handleMySegmentUpdateCall = function __handleMySegmentUpdateCall() {
    var _this = this;

    if (this.maxChangeNumber > this.currentChangeNumber) {
      this.handleNewEvent = false;
      var currentMaxChangeNumber = this.maxChangeNumber; // fetch mySegments revalidating data if cached

      this.mySegmentsProducer.synchronizeMySegments(this.segmentsData, true).then(function (result) {
        if (result !== false) // Unlike `Split\SegmentUpdateWorker`, we cannot use `mySegmentsStorage.getChangeNumber` since `/mySegments` endpoint doesn't provide this value.
          _this.currentChangeNumber = Math.max(_this.currentChangeNumber, currentMaxChangeNumber); // use `currentMaxChangeNumber`, in case that `this.maxChangeNumber` was updated during fetch.

        if (_this.handleNewEvent) {
          _this.__handleMySegmentUpdateCall();
        } else {
          _this.backoff.scheduleCall();
        }
      });
    }
  }
  /**
   * Invoked by NotificationProcessor on MY_SEGMENTS_UPDATE event
   *
   * @param {number} changeNumber change number of the MY_SEGMENTS_UPDATE notification
   * @param {string[] | { name: string, add: boolean } | undefined} segmentsData might be undefined
   */
  ;

  _proto.put = function put(changeNumber, segmentsData) {
    // @TODO uncomment next line once `/mySegments` endpoint provides the changeNumber
    // const currentChangeNumber = this.mySegmentsStorage.getChangeNumber();
    if (changeNumber <= this.currentChangeNumber || changeNumber <= this.maxChangeNumber) return;
    this.maxChangeNumber = changeNumber;
    this.handleNewEvent = true;
    this.backoff.reset();
    this.segmentsData = segmentsData;
    if (this.mySegmentsProducer.isSynchronizingMySegments()) return;

    this.__handleMySegmentUpdateCall();
  };

  return MySegmentUpdateWorker;
}();

export { MySegmentUpdateWorker as default };